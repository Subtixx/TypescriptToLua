"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var ts = require("typescript");
var TSHelper_1 = require("./TSHelper");
var ForHelper_1 = require("./ForHelper");
var path = require("path");
var TranspileError = /** @class */ (function (_super) {
    __extends(TranspileError, _super);
    function TranspileError(message, node) {
        var _this = _super.call(this, message) || this;
        _this.node = node;
        return _this;
    }
    return TranspileError;
}(Error));
exports.TranspileError = TranspileError;
var LuaTranspiler = /** @class */ (function () {
    function LuaTranspiler(checker) {
        this.indent = "";
        this.checker = checker;
        this.genVarCounter = 0;
        this.transpilingSwitch = false;
        this.namespace = [];
        this.importCount = 0;
        this.isModule = false;
    }
    // Transpile a source file
    LuaTranspiler.transpileSourceFile = function (node, checker, addHeader) {
        var transpiler = new LuaTranspiler(checker);
        var header = addHeader ? "--=======================================================================================\n"
            + "-- Generated by TypescriptToLua transpiler https://github.com/Perryvw/TypescriptToLua \n"
            + "-- Date: " + new Date().toDateString() + "\n"
            + "--=======================================================================================\n"
            : "";
        var result = header;
        transpiler.isModule = TSHelper_1.TSHelper.isFileModule(node);
        if (transpiler.isModule) {
            // Shadow exports if it already exists
            result += "local exports = exports or {}\n";
        }
        result += transpiler.transpileBlock(node);
        if (transpiler.isModule) {
            result += "return exports\n";
        }
        return result;
    };
    LuaTranspiler.prototype.pushIndent = function () {
        this.indent = this.indent + "    ";
    };
    LuaTranspiler.prototype.popIndent = function () {
        this.indent = this.indent.slice(4);
    };
    LuaTranspiler.prototype.definitionName = function (name) {
        return this.namespace.concat(name).join(".");
    };
    LuaTranspiler.prototype.accessPrefix = function (node) {
        return node && this.isModule ?
            "local " : "";
    };
    LuaTranspiler.prototype.makeExport = function (name, node) {
        var result = "";
        if (node && node.modifiers && (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export)) {
            result = this.indent + ("exports." + this.definitionName(name) + " = " + name + "\n");
        }
        if (this.namespace.length !== 0) {
            result += this.indent + (this.definitionName(name) + " = " + name + "\n");
        }
        return result;
    };
    // Transpile a block
    LuaTranspiler.prototype.transpileBlock = function (node) {
        var _this = this;
        var result = "";
        if (ts.isBlock(node)) {
            node.statements.forEach(function (statement) {
                result += _this.transpileNode(statement);
            });
        }
        else {
            node.forEachChild(function (child) {
                result += _this.transpileNode(child);
            });
        }
        return result;
    };
    // Transpile a node of unknown kind.
    LuaTranspiler.prototype.transpileNode = function (node) {
        //Ignore declarations
        if (TSHelper_1.TSHelper.getChildrenOfType(node, function (child) { return child.kind == ts.SyntaxKind.DeclareKeyword; }).length > 0)
            return "";
        switch (node.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                return this.transpileImport(node);
            case ts.SyntaxKind.ClassDeclaration:
                return this.transpileClass(node);
            case ts.SyntaxKind.ModuleDeclaration:
                return this.transpileNamespace(node);
            case ts.SyntaxKind.ModuleBlock:
                return this.transpileBlock(node);
            case ts.SyntaxKind.EnumDeclaration:
                return this.transpileEnum(node);
            case ts.SyntaxKind.FunctionDeclaration:
                return this.transpileFunctionDeclaration(node);
            case ts.SyntaxKind.VariableStatement:
                return this.indent + this.transpileVariableStatement(node) + "\n";
            case ts.SyntaxKind.ExpressionStatement:
                return this.indent + this.transpileExpression(TSHelper_1.TSHelper.getChildren(node)[0]) + "\n";
            case ts.SyntaxKind.ReturnStatement:
                return this.indent + this.transpileReturn(node) + "\n";
            case ts.SyntaxKind.IfStatement:
                return this.transpileIf(node);
            case ts.SyntaxKind.WhileStatement:
                return this.transpileWhile(node);
            case ts.SyntaxKind.ForStatement:
                return this.transpileFor(node);
            case ts.SyntaxKind.ForOfStatement:
                return this.transpileForOf(node);
            case ts.SyntaxKind.ForInStatement:
                return this.transpileForIn(node);
            case ts.SyntaxKind.SwitchStatement:
                return this.transpileSwitch(node);
            case ts.SyntaxKind.BreakStatement:
                return this.transpileBreak();
            case ts.SyntaxKind.ContinueKeyword:
                // Disallow continue
                throw new TranspileError("Continue is not supported in Lua", node);
            case ts.SyntaxKind.TypeAliasDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.EndOfFileToken:
                // Ignore these
                return "";
            default:
                return this.indent + this.transpileExpression(node) + "\n";
        }
    };
    LuaTranspiler.prototype.transpileImport = function (node) {
        var importFile = this.transpileExpression(node.moduleSpecifier);
        if (!node.importClause) {
            throw new TranspileError("Default Imports are not supported, please use named imports instead!", node);
        }
        var imports = node.importClause.namedBindings;
        if (ts.isNamedImports(imports)) {
            var fileImportTable_1 = path.basename(importFile.replace(new RegExp("\"", "g"), "")) + this.importCount;
            var result_1 = "local " + fileImportTable_1 + " = require(" + importFile + ")\n";
            this.importCount++;
            imports.elements.forEach(function (element) {
                if (element.propertyName) {
                    result_1 += "local " + element.name.escapedText + " = " + fileImportTable_1 + "." + element.propertyName.escapedText + "\n";
                }
                else {
                    result_1 += "local " + element.name.escapedText + " = " + fileImportTable_1 + "." + element.name.escapedText + "\n";
                }
            });
            return result_1;
        }
        else {
            throw new TranspileError("Unsupported import type.", node);
        }
    };
    LuaTranspiler.prototype.transpileNamespace = function (node) {
        // If phantom namespace just transpile the body as normal
        if (TSHelper_1.TSHelper.isPhantom(this.checker.getTypeAtLocation(node), this.checker))
            return this.transpileNode(node.body);
        var defName = this.definitionName(node.name.text);
        var result = this.indent + this.accessPrefix(node) + (node.name.text + " = " + node.name.text + " or {}\n");
        if (this.namespace.length > 0) {
            result += this.indent + (defName + " = " + node.name.text + " or {}\n");
        }
        result += this.makeExport(defName, node);
        // Create closure
        result += this.indent + "do\n";
        this.pushIndent();
        this.namespace.push(node.name.text);
        result += this.transpileNode(node.body);
        this.namespace.pop();
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileEnum = function (node) {
        var _this = this;
        var val = 0;
        var result = "";
        var type = this.checker.getTypeAtLocation(node);
        var membersOnly = TSHelper_1.TSHelper.isCompileMembersOnlyEnum(type, this.checker);
        if (!membersOnly) {
            var name_1 = node.name.escapedText;
            result += this.indent + this.accessPrefix(node) + (name_1 + "={}\n");
            result += this.makeExport(name_1, node);
        }
        node.members.forEach(function (member) {
            if (member.initializer) {
                if (ts.isNumericLiteral(member.initializer)) {
                    val = parseInt(member.initializer.text);
                }
                else {
                    throw new TranspileError("Only numeric initializers allowed for enums.", node);
                }
            }
            if (membersOnly) {
                var defName = _this.definitionName(member.name.escapedText);
                result += _this.indent + (defName + "=" + val + "\n");
            }
            else {
                var defName = _this.definitionName(node.name.escapedText + "." + member.name.escapedText);
                result += _this.indent + (defName + "=" + val + "\n");
            }
            val++;
        });
        return result;
    };
    LuaTranspiler.prototype.transpileBreak = function () {
        if (this.transpilingSwitch) {
            return this.indent + ("goto switchDone" + this.genVarCounter + "\n");
        }
        else {
            return this.indent + "break\n";
        }
    };
    LuaTranspiler.prototype.transpileIf = function (node) {
        var condition = this.transpileExpression(node.expression);
        var result = this.indent + ("if " + condition + " then\n");
        this.pushIndent();
        result += this.transpileStatement(node.thenStatement);
        this.popIndent();
        if (node.elseStatement) {
            result += this.indent + "else\n";
            this.pushIndent();
            result += this.transpileStatement(node.elseStatement);
            this.popIndent();
        }
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileWhile = function (node) {
        var condition = this.transpileExpression(node.expression);
        var result = this.indent + ("while " + condition + " do\n");
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileFor = function (node) {
        // Get iterator variable
        var variable = node.initializer.declarations[0];
        var identifier = variable.name;
        // Populate three components of lua numeric for loop:
        var start = this.transpileExpression(variable.initializer);
        var end = ForHelper_1.ForHelper.GetForEnd(node.condition, this);
        var step = ForHelper_1.ForHelper.GetForStep(node.incrementor, this);
        // Add header
        var result = this.indent + ("for " + identifier.escapedText + "=" + start + "," + end + "," + step + " do\n");
        // Add body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileForOf = function (node) {
        // Get variable identifier
        var variable = node.initializer.declarations[0];
        var identifier = variable.name;
        // Transpile expression
        var expression = this.transpileExpression(node.expression);
        // Use ipairs for array types, pairs otherwise
        var isArray = TSHelper_1.TSHelper.isArrayType(this.checker.getTypeAtLocation(node.expression));
        var pairs = isArray ? "ipairs" : "pairs";
        // Make header
        var result = this.indent + ("for _, " + identifier.escapedText + " in " + pairs + "(" + expression + ") do\n");
        // For body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileForIn = function (node) {
        // Get variable identifier
        var variable = node.initializer.declarations[0];
        var identifier = variable.name;
        // Transpile expression
        var expression = this.transpileExpression(node.expression);
        if (TSHelper_1.TSHelper.isArrayType(this.checker.getTypeAtLocation(node.expression))) {
            throw new TranspileError("Iterating over arrays with 'for in' is not allowed.", node);
        }
        // Make header
        var result = this.indent + ("for " + identifier.escapedText + ", _ in pairs(" + expression + ") do\n");
        // For body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileStatement = function (node) {
        if (ts.isBlock(node)) {
            return this.transpileBlock(node);
        }
        else {
            return this.transpileNode(node);
        }
    };
    LuaTranspiler.prototype.transpileSwitch = function (node) {
        var _this = this;
        var expression = this.transpileExpression(node.expression, true);
        var clauses = node.caseBlock.clauses;
        var result = this.indent + "-------Switch statement start-------\n";
        // If statement to go to right entry label
        clauses.forEach(function (clause, index) {
            if (ts.isCaseClause(clause)) {
                var keyword = index == 0 ? "if" : "elseif";
                var condition = _this.transpileExpression(clause.expression, true);
                result += _this.indent + (keyword + " " + expression + "==" + condition + " then\n");
            }
            else {
                // Default
                result += _this.indent + "else\n";
            }
            _this.pushIndent();
            // Labels for fallthrough
            result += _this.indent + ("::switchCase" + (_this.genVarCounter + index) + "::\n");
            _this.transpilingSwitch = true;
            clause.statements.forEach(function (statement) {
                result += _this.transpileNode(statement);
            });
            _this.transpilingSwitch = false;
            // If this goto is reached, fall through to the next case
            if (index < clauses.length - 1) {
                result += _this.indent + ("goto switchCase" + (_this.genVarCounter + index + 1) + "\n");
            }
            _this.popIndent();
        });
        result += this.indent + "end\n";
        result += this.indent + ("::switchDone" + this.genVarCounter + "::\n");
        result += this.indent + "--------Switch statement end--------\n";
        //Increment counter for next switch statement
        this.genVarCounter += clauses.length;
        return result;
    };
    LuaTranspiler.prototype.transpileReturn = function (node) {
        if (node.expression) {
            return "return " + this.transpileExpression(node.expression);
        }
        else {
            return "return";
        }
    };
    LuaTranspiler.prototype.transpileExpression = function (node, brackets) {
        switch (node.kind) {
            case ts.SyntaxKind.BinaryExpression:
                // Add brackets to preserve ordering
                return this.transpileBinaryExpression(node, brackets);
            case ts.SyntaxKind.ConditionalExpression:
                // Add brackets to preserve ordering
                return this.transpileConditionalExpression(node, brackets);
            case ts.SyntaxKind.CallExpression:
                return this.transpileCallExpression(node);
            case ts.SyntaxKind.PropertyAccessExpression:
                return this.transpilePropertyAccessExpression(node);
            case ts.SyntaxKind.ElementAccessExpression:
                return this.transpileElementAccessExpression(node);
            case ts.SyntaxKind.Identifier:
                // For identifiers simply return their name
                return node.text;
            case ts.SyntaxKind.StringLiteral:
                var text = node.text;
                return "\"" + text + "\"";
            case ts.SyntaxKind.TemplateExpression:
                return this.transpileTemplateExpression(node);
            case ts.SyntaxKind.NumericLiteral:
                return node.text;
            case ts.SyntaxKind.TrueKeyword:
                return "true";
            case ts.SyntaxKind.FalseKeyword:
                return "false";
            case ts.SyntaxKind.NullKeyword:
                return "nil";
            case ts.SyntaxKind.ThisKeyword:
                return "self";
            case ts.SyntaxKind.PostfixUnaryExpression:
                return this.transpilePostfixUnaryExpression(node);
            case ts.SyntaxKind.PrefixUnaryExpression:
                return this.transpilePrefixUnaryExpression(node);
            case ts.SyntaxKind.ArrayLiteralExpression:
                return this.transpileArrayLiteral(node);
            case ts.SyntaxKind.ObjectLiteralExpression:
                return this.transpileObjectLiteral(node);
            case ts.SyntaxKind.DeleteExpression:
                return this.transpileExpression(node.expression) + "=nil";
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ArrowFunction:
                return this.transpileArrowFunction(node);
            case ts.SyntaxKind.NewExpression:
                return this.transpileNewExpression(node);
            case ts.SyntaxKind.ComputedPropertyName:
                return "[" + this.transpileExpression(node.expression) + "]";
            case ts.SyntaxKind.ParenthesizedExpression:
                return "(" + this.transpileExpression(node.expression) + ")";
            case ts.SyntaxKind.SuperKeyword:
                return "self.__base";
            case ts.SyntaxKind.TypeAssertionExpression:
                // Simply ignore the type assertion
                return this.transpileExpression(node.expression);
            case ts.SyntaxKind.AsExpression:
                // Also ignore as casts
                return this.transpileExpression(node.expression);
            case ts.SyntaxKind.TypeOfExpression:
                return this.transpileTypeOfExpression(node);
            default:
                throw new TranspileError("Unsupported expression kind: " + TSHelper_1.TSHelper.enumName(node.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpileTypeOfExpression = function (node) {
        // This produces type((name))??
        var name = this.transpileExpression(node.expression);
        return "type(" + name + ")";
    };
    LuaTranspiler.prototype.transpileBinaryExpression = function (node, brackets) {
        // Transpile operands
        var lhs = this.transpileExpression(node.left, true);
        var rhs = this.transpileExpression(node.right, true);
        // Rewrite some non-existant binary operators
        var result = "";
        switch (node.operatorToken.kind) {
            case ts.SyntaxKind.PlusEqualsToken:
                result = lhs + "=" + lhs + "+" + rhs;
                break;
            case ts.SyntaxKind.MinusEqualsToken:
                result = lhs + "=" + lhs + "-" + rhs;
                break;
            case ts.SyntaxKind.AsteriskEqualsToken:
                result = lhs + "=" + lhs + "*" + rhs;
                break;
            case ts.SyntaxKind.SlashEqualsToken:
                result = lhs + "=" + lhs + "/" + rhs;
                break;
            case ts.SyntaxKind.AmpersandAmpersandToken:
                result = lhs + " and " + rhs;
                break;
            case ts.SyntaxKind.BarBarToken:
                result = lhs + " or " + rhs;
                break;
            case ts.SyntaxKind.AmpersandToken:
                result = "bit.band(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.AmpersandEqualsToken:
                result = lhs + "=bit.band(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.BarToken:
                result = "bit.bor(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.BarEqualsToken:
                result = lhs + "=bit.bor(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.LessThanLessThanToken:
                result = "bit.lshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.LessThanLessThanEqualsToken:
                result = lhs + "=bit.lshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.GreaterThanGreaterThanToken:
                result = "bit.arshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                result = lhs + "=bit.arshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                result = "bit.rshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                result = lhs + "=bit.rshift(" + lhs + "," + rhs + ")";
                break;
            case ts.SyntaxKind.PlusToken:
                // Replace string + with ..
                var typeLeft = this.checker.getTypeAtLocation(node.left);
                if (typeLeft.flags & ts.TypeFlags.String || ts.isStringLiteral(node.left))
                    return lhs + ".." + rhs;
            default:
                result = lhs + this.transpileOperator(node.operatorToken) + rhs;
        }
        // Optionally put brackets around result
        if (brackets) {
            return "(" + result + ")";
        }
        else {
            return result;
        }
    };
    LuaTranspiler.prototype.transpileTemplateExpression = function (node) {
        var _this = this;
        var parts = ["\"" + node.head.text + "\""];
        node.templateSpans.forEach(function (span) {
            var expr = _this.transpileExpression(span.expression, true);
            if (ts.isTemplateTail(span.literal)) {
                parts.push(expr + ("..\"" + span.literal.text + "\""));
            }
            else {
                parts.push(expr + ("..\"" + span.literal.text + "\""));
            }
        });
        return parts.join("..");
    };
    LuaTranspiler.prototype.transpileConditionalExpression = function (node, brackets) {
        var condition = this.transpileExpression(node.condition);
        var val1 = this.transpileExpression(node.whenTrue);
        var val2 = this.transpileExpression(node.whenFalse);
        return "TS_ITE(" + condition + ",function() return " + val1 + " end,function() return " + val2 + " end)";
    };
    // Replace some missmatching operators
    LuaTranspiler.prototype.transpileOperator = function (operator) {
        switch (operator.kind) {
            case ts.SyntaxKind.EqualsEqualsEqualsToken:
                return "==";
            case ts.SyntaxKind.ExclamationEqualsToken:
            case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                return "~=";
            default:
                return ts.tokenToString(operator.kind);
        }
    };
    LuaTranspiler.prototype.transpilePostfixUnaryExpression = function (node) {
        var operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.PlusPlusToken:
                return operand + "=" + operand + "+1";
            case ts.SyntaxKind.MinusMinusToken:
                return operand + "=" + operand + "-1";
            default:
                throw new TranspileError("Unsupported unary postfix: " + TSHelper_1.TSHelper.enumName(node.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpilePrefixUnaryExpression = function (node) {
        var operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.PlusPlusToken:
                return operand + "=" + operand + "+1";
            case ts.SyntaxKind.MinusMinusToken:
                return operand + "=" + operand + "-1";
            case ts.SyntaxKind.ExclamationToken:
                return "not " + operand;
            case ts.SyntaxKind.MinusToken:
                return "-" + operand;
            default:
                throw new TranspileError("Unsupported unary prefix: " + TSHelper_1.TSHelper.enumName(node.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpileNewExpression = function (node) {
        var name = this.transpileExpression(node.expression);
        var params = this.transpileArguments(node.arguments, ts.createTrue());
        return name + ".new(" + params + ")";
    };
    LuaTranspiler.prototype.transpileCallExpression = function (node) {
        // Check for calls on primitives to override
        if (ts.isPropertyAccessExpression(node.expression)) {
            var type = this.checker.getTypeAtLocation(node.expression.expression);
            switch (type.flags) {
                case ts.TypeFlags.String:
                case ts.TypeFlags.StringLiteral:
                    return this.transpileStringCallExpression(node);
                case ts.TypeFlags.Object:
                    if (TSHelper_1.TSHelper.isArrayType(type))
                        return this.transpileArrayCallExpression(node);
            }
            var expType = this.checker.getTypeAtLocation(node.expression.expression);
            if (expType.symbol && expType.symbol.escapedName == "Math") {
                var params_1 = this.transpileArguments(node.arguments);
                return this.transpileMathExpression(node.expression.name) + ("(" + params_1 + ")");
            }
            // Include context parameter if present
            var callPath_1 = (expType && expType.symbol) ? expType.symbol.name + "." + node.expression.name.escapedText : this.transpileExpression(node.expression);
            var params_2 = this.transpileArguments(node.arguments, node.expression.expression);
            //? Workaround: MTA.addEventHandler(MTA, args) to addEventHandler(args)!
            if (TSHelper_1.TSHelper.isPhantom(expType, this.checker)) {
                var paramsContextFree = this.transpileArguments(node.arguments);
                return node.expression.name.escapedText + "(" + paramsContextFree + ")";
            }
            return callPath_1 + "(" + params_2 + ")";
        }
        // Handle super calls properly
        if (node.expression.kind == ts.SyntaxKind.SuperKeyword) {
            var callPath_2 = this.transpileExpression(node.expression);
            var params_3 = this.transpileArguments(node.arguments, ts.createNode(ts.SyntaxKind.ThisKeyword));
            return "self.__base.constructor(" + params_3 + ")";
        }
        var callPath = this.transpileExpression(node.expression);
        var params = this.transpileArguments(node.arguments);
        return callPath + "(" + params + ")";
    };
    LuaTranspiler.prototype.transpileStringCallExpression = function (node) {
        var expression = node.expression;
        var params = this.transpileArguments(node.arguments);
        var caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "replace":
                return "string.sub(" + caller + "," + params + ")";
            case "indexOf":
                if (node.arguments.length == 1) {
                    return "(string.find(" + caller + "," + params + ",1,true) or 0)-1";
                }
                else {
                    return "(string.find(" + caller + "," + params + "+1,true) or 0)-1";
                }
            case "substring":
                if (node.arguments.length == 1) {
                    return "string.sub(" + caller + "," + params + "+1)";
                }
                else {
                    var arg1 = this.transpileExpression(node.arguments[0]);
                    var arg2 = this.transpileExpression(node.arguments[1]);
                    return "string.sub(" + caller + "," + arg1 + "+1," + arg2 + "+1)";
                }
            default:
                throw new TranspileError("Unsupported string function: " + expression.name.escapedText, node);
        }
    };
    // Transpile a String._ property
    LuaTranspiler.prototype.transpileStringExpression = function (identifier) {
        var translation = {
            fromCharCode: "string.char",
            fromCodePoint: "utf8.char"
        };
        // TODO at check if compiler options is LUA 5.3
        // should throw an exception if codepoint is used sub 5.3
        if (translation[identifier.escapedText]) {
            return "" + translation[identifier.escapedText];
        }
        else {
            throw new TranspileError("Unsupported string property " + identifier.escapedText + ".", identifier);
        }
    };
    LuaTranspiler.prototype.transpileArrayCallExpression = function (node) {
        var expression = node.expression;
        var params = this.transpileArguments(node.arguments);
        var caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "push":
                if (node.arguments.length > 1) {
                    throw new TranspileError("Unsupported array function: " + expression.name.escapedText + " with more than one argument", node);
                }
                return "table.insert(" + caller + ", " + params + ")";
            case "forEach":
                return "TS_forEach(" + caller + ", " + params + ")";
            case "map":
                return "TS_map(" + caller + ", " + params + ")";
            case "filter":
                return "TS_filter(" + caller + ", " + params + ")";
            case "some":
                return "TS_some(" + caller + ", " + params + ")";
            case "every":
                return "TS_every(" + caller + ", " + params + ")";
            case "slice":
                return "TS_slice(" + caller + ", " + params + ")";
            case "splice":
                return "TS_splice(" + caller + ", " + params + ")";
            case "join":
                return "table.concat(" + caller + ", " + params + ")";
            default:
                throw new TranspileError("Unsupported array function: " + expression.name.escapedText, node);
        }
    };
    LuaTranspiler.prototype.transpileArguments = function (params, context) {
        var _this = this;
        var parameters = [];
        // Add context as first param if present
        if (context) {
            parameters.push(this.transpileExpression(context));
        }
        params.forEach(function (param) {
            parameters.push(_this.transpileExpression(param));
        });
        return parameters.join(",");
    };
    LuaTranspiler.prototype.transpilePropertyAccessExpression = function (node) {
        var property = node.name.text;
        // Check for primitive types to override
        var type = this.checker.getTypeAtLocation(node.expression);
        switch (type.flags) {
            case ts.TypeFlags.String:
            case ts.TypeFlags.StringLiteral:
                return this.transpileStringProperty(node);
            case ts.TypeFlags.Object:
                if (TSHelper_1.TSHelper.isArrayType(type))
                    return this.transpileArrayProperty(node);
        }
        // Do not output path for member only enums
        if (TSHelper_1.TSHelper.isCompileMembersOnlyEnum(type, this.checker)) {
            return property;
        }
        // Catch math expressions
        if (ts.isIdentifier(node.expression) && node.expression.escapedText == "Math") {
            return this.transpileMathExpression(node.name);
        }
        if (TSHelper_1.TSHelper.isPhantom(type, this.checker)) {
            return "" + property;
        }
        var path = this.transpileExpression(node.expression);
        return path + "." + property;
    };
    // Transpile a Math._ property
    LuaTranspiler.prototype.transpileMathExpression = function (identifier) {
        var translation = {
            abs: "abs",
            acos: "acos",
            asin: "asin",
            atan: "atan",
            ceil: "ceil",
            cos: "cos",
            exp: "exp",
            floor: "floor",
            log: "log",
            max: "max",
            min: "min",
            PI: "pi",
            pow: "pow",
            random: "random",
            round: "round",
            sin: "sin",
            sqrt: "sqrt",
            tan: "tan"
        };
        if (translation[identifier.escapedText]) {
            return "math." + translation[identifier.escapedText];
        }
        else {
            throw new TranspileError("Unsupported math property " + identifier.escapedText + ".", identifier);
        }
    };
    // Transpile access of string properties, only supported properties are allowed
    LuaTranspiler.prototype.transpileStringProperty = function (node) {
        var property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported string property: " + property.escapedText, node);
        }
    };
    // Transpile access of array properties, only supported properties are allowed
    LuaTranspiler.prototype.transpileArrayProperty = function (node) {
        var property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported array property: " + property.escapedText, node);
        }
    };
    LuaTranspiler.prototype.transpileElementAccessExpression = function (node) {
        var element = this.transpileExpression(node.expression);
        var index = this.transpileExpression(node.argumentExpression);
        var type = this.checker.getTypeAtLocation(node.expression);
        if (TSHelper_1.TSHelper.isArrayType(type) || TSHelper_1.TSHelper.isTupleType(type)) {
            return element + "[" + index + "+1]";
        }
        else if (TSHelper_1.TSHelper.isStringType(type)) {
            return "string.sub(" + element + "," + index + "+1," + index + "+1)";
        }
        else {
            return element + "[" + index + "]";
        }
    };
    // Transpile a variable statement
    LuaTranspiler.prototype.transpileVariableStatement = function (node) {
        var _this = this;
        var result = "";
        node.declarationList.declarations.forEach(function (declaration) {
            result += _this.transpileVariableDeclaration(declaration);
            result += _this.makeExport(declaration.name.escapedText, node);
        });
        return result;
    };
    LuaTranspiler.prototype.transpileVariableDeclaration = function (node) {
        if (ts.isIdentifier(node.name)) {
            // Find variable identifier
            var identifier = node.name;
            if (node.initializer) {
                var value = this.transpileExpression(node.initializer);
                return "local " + identifier.escapedText + " = " + value + "\n";
            }
            else {
                return "local " + identifier.escapedText + " = nil\n";
            }
        }
        else if (ts.isArrayBindingPattern(node.name)) {
            // Destructuring type
            var value = this.transpileExpression(node.initializer);
            var result_2 = "local ";
            var length_1 = node.name.elements.length;
            node.name.elements.forEach(function (elem, index) {
                result_2 += "" + elem.name.escapedText;
                if (index != length_1 - 1)
                    result_2 += ",";
            });
            result_2 += " = " + value + "\n";
            return result_2;
            /*const value = this.transpileExpression(node.initializer);
            let parentName = `__destr${this.genVarCounter}`;
            this.genVarCounter++;
            let result = `local ${parentName} = ${value}\n`;
            node.name.elements.forEach((elem: ts.BindingElement, index: number) => {
                if (!elem.dotDotDotToken) {
                    result += this.indent + `local ${(<ts.Identifier>elem.name).escapedText} = ${parentName}[${index + 1}]\n`;
                } else {
                    result += this.indent + `local ${(<ts.Identifier>elem.name).escapedText} = TS_slice(${parentName}, ${index})\n`;
                }
            });
            return result;*/
        }
        else {
            throw new TranspileError("Unsupported variable declaration type " + TSHelper_1.TSHelper.enumName(node.name.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpileFunctionDeclaration = function (node) {
        var result = "";
        var identifier = node.name;
        var methodName = identifier.escapedText;
        var parameters = node.parameters;
        var body = node.body;
        // Build parameter string
        var paramNames = [];
        parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        // Build function header
        result += this.indent + this.accessPrefix(node) + ("function " + methodName + "(" + paramNames.join(",") + ")\n");
        this.pushIndent();
        result += this.transpileBlock(body);
        this.popIndent();
        // Close function block
        result += this.indent + "end\n";
        result += this.makeExport(methodName, node);
        return result;
    };
    LuaTranspiler.prototype.transpileMethodDeclaration = function (node, path) {
        var result = "";
        var identifier = node.name;
        var methodName = identifier.escapedText;
        var parameters = node.parameters;
        var body = node.body;
        // Build parameter string
        var paramNames = ["self"];
        parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        // Build function header
        result += this.indent + ("function " + path + methodName + "(" + paramNames.join(",") + ")\n");
        this.pushIndent();
        result += this.transpileBlock(body);
        this.popIndent();
        // Close function block
        result += this.indent + "end\n";
        return result;
    };
    // Transpile a class declaration
    LuaTranspiler.prototype.transpileClass = function (node) {
        var _this = this;
        // Find extends class, ignore implements
        var extendsType;
        var noClassOr = false;
        if (node.heritageClauses)
            node.heritageClauses.forEach(function (clause) {
                if (clause.token == ts.SyntaxKind.ExtendsKeyword) {
                    var superType = _this.checker.getTypeAtLocation(clause.types[0]);
                    // Ignore purely abstract types (decorated with /** @PureAbstract */)
                    if (!TSHelper_1.TSHelper.isPureAbstractClass(superType, _this.checker)) {
                        extendsType = clause.types[0];
                    }
                    noClassOr = TSHelper_1.TSHelper.hasCustomDecorator(superType, _this.checker, "!NoClassOr");
                }
            });
        var className = node.name.escapedText;
        var result = "";
        // Skip header if this is an extension class
        var isExtension = TSHelper_1.TSHelper.isExtensionClass(this.checker.getTypeAtLocation(node), this.checker);
        if (!isExtension) {
            // Write class declaration
            var classOr = noClassOr ? "" : className + " or ";
            if (!extendsType) {
                result += this.indent + this.accessPrefix(node) + (className + " = " + classOr + "{}\n");
                result += this.makeExport(className, node);
            }
            else {
                var baseName = extendsType.expression.escapedText;
                result += this.indent + this.accessPrefix(node) + (className + " = " + classOr + baseName + ".new()\n");
                result += this.makeExport(className, node);
            }
            result += this.indent + (className + ".__index = " + className + "\n");
            if (extendsType) {
                var baseName = extendsType.expression.escapedText;
                result += this.indent + (className + ".__base = " + baseName + "\n");
            }
            result += this.indent + ("function " + className + ".new(construct, ...)\n");
            result += this.indent + ("    local instance = setmetatable({}, " + className + ")\n");
            result += this.indent + ("    if construct and " + className + ".constructor then " + className + ".constructor(instance, ...) end\n");
            result += this.indent + "    return instance\n";
            result += this.indent + "end\n";
        }
        else {
            // Overwrite the original className with the class we are overriding for extensions
            if (extendsType) {
                className = extendsType.expression.escapedText;
            }
        }
        // Get all properties with value
        var properties = node.members.filter(ts.isPropertyDeclaration)
            .filter(function (_) { return _.initializer; });
        // Divide properties into static and non-static
        var isStatic = function (_) { return _.modifiers && _.modifiers.some(function (_) { return _.kind == ts.SyntaxKind.StaticKeyword; }); };
        var staticFields = properties.filter(isStatic);
        var instanceFields = properties.filter(function (_) { return !isStatic(_); });
        // Add static declarations
        for (var _i = 0, staticFields_1 = staticFields; _i < staticFields_1.length; _i++) {
            var field = staticFields_1[_i];
            var fieldName = field.name.escapedText;
            var value = this.transpileExpression(field.initializer);
            result += this.indent + (className + "." + fieldName + " = " + value + "\n");
        }
        // Try to find constructor
        var constructor = node.members.filter(ts.isConstructorDeclaration)[0];
        if (constructor) {
            // Add constructor plus initialisation of instance fields
            result += this.transpileConstructor(constructor, className, instanceFields);
        }
        else {
            // No constructor, make one to set all instance fields if there are any
            if (instanceFields.length > 0) {
                // Create empty constructor and add instance fields
                result += this.transpileConstructor(ts.createConstructor([], [], [], ts.createBlock([], true)), className, instanceFields);
            }
        }
        // Transpile methods
        node.members.filter(ts.isMethodDeclaration).forEach(function (method) {
            result += _this.transpileMethodDeclaration(method, className + ".");
        });
        // Check if the class should be returned
        var isExport = node.modifiers && node.modifiers.some(function (_) { return _.kind == ts.SyntaxKind.ExportKeyword; });
        var isDefault = node.modifiers && node.modifiers.some(function (_) { return _.kind == ts.SyntaxKind.DefaultKeyword; });
        if (isExport && isDefault) {
            result += this.indent + ("return " + className + "\n");
        }
        return result;
    };
    LuaTranspiler.prototype.transpileConstructor = function (node, className, instanceFields) {
        var extraInstanceFields = [];
        var parameters = ["self"];
        node.parameters.forEach(function (param) {
            // If param has decorators, add extra instance field
            if (param.modifiers != undefined)
                extraInstanceFields.push(param.name.escapedText);
            // Add to parameter list
            parameters.push(param.name.escapedText);
        });
        var result = this.indent + ("function " + className + ".constructor(" + parameters.join(",") + ")\n");
        // Add in instance field declarations
        for (var _i = 0, extraInstanceFields_1 = extraInstanceFields; _i < extraInstanceFields_1.length; _i++) {
            var f = extraInstanceFields_1[_i];
            result += this.indent + ("    self." + f + " = " + f + "\n");
        }
        for (var _a = 0, instanceFields_1 = instanceFields; _a < instanceFields_1.length; _a++) {
            var f = instanceFields_1[_a];
            // Get identifier
            var fieldIdentifier = f.name;
            var fieldName = fieldIdentifier.escapedText;
            var value = this.transpileExpression(f.initializer);
            result += this.indent + ("    self." + fieldName + " = " + value + "\n");
        }
        // Transpile constructor body
        this.pushIndent();
        result += this.transpileBlock(node.body);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileArrayLiteral = function (node) {
        var _this = this;
        var values = [];
        node.elements.forEach(function (child) {
            values.push(_this.transpileExpression(child));
        });
        return "{" + values.join(",") + "}";
    };
    LuaTranspiler.prototype.transpileObjectLiteral = function (node) {
        var _this = this;
        var properties = [];
        // Add all property assignments
        node.properties.forEach(function (assignment) {
            var _a = TSHelper_1.TSHelper.getChildren(assignment), key = _a[0], value = _a[1];
            if (ts.isIdentifier(key)) {
                properties.push(key.escapedText + "=" + _this.transpileExpression(value));
            }
            else if (ts.isComputedPropertyName(key)) {
                var index = _this.transpileExpression(key);
                properties.push(index + "=" + _this.transpileExpression(value));
            }
            else {
                var index = _this.transpileExpression(key);
                properties.push("[" + index + "]=" + _this.transpileExpression(value));
            }
        });
        return "{" + properties.join(",") + "}";
    };
    LuaTranspiler.prototype.transpileFunctionExpression = function (node) {
        // Build parameter string
        var paramNames = [];
        node.parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        var result = "function(" + paramNames.join(",") + ")\n";
        this.pushIndent();
        result += this.transpileBlock(node.body);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileArrowFunction = function (node) {
        // Build parameter string
        var paramNames = [];
        node.parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        if (ts.isBlock(node.body)) {
            var result = "function(" + paramNames.join(",") + ")\n";
            this.pushIndent();
            result += this.transpileBlock(node.body);
            this.popIndent();
            return result + this.indent + "end\n";
        }
        else {
            return "function(" + paramNames.join(",") + ") return " + this.transpileExpression(node.body) + " end";
        }
    };
    return LuaTranspiler;
}());
exports.LuaTranspiler = LuaTranspiler;
